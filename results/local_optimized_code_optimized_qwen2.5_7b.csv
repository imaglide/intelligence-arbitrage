experiment_id,model,task,example_id,prediction,ground_truth,is_correct,latency_ms,timestamp
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,0,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
    numbers.sort()
    for i in range(len(numbers) - 1):
        if numbers[i + 1] - numbers[i] < threshold:
            return True
    return False","    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True

    return False
",True,11986.017,2026-02-06T21:10:54.066575
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,1,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    result = []
    balance = 0
    current_group = ''
    
    for char in paren_string.replace("" "", """"):
        current_group += char
        if char == '(':
            balance += 1
        elif char == ')':
            balance -= 1
        
        if balance == 0 and current_group:
            result.append(current_group)
            current_group = ''
    
    return result","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
",True,8146.157999999999,2026-02-06T21:11:02.212753
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,2,"```python
def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    """"""
    return number % 1

# Test cases
assert truncate_number(3.5) == 0.5
assert truncate_number(4.75) == 0.75
```","    return number % 1.0
",True,10381.057,2026-02-06T21:11:12.593829
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,3,"from typing import List


def below_zero(operations: List[int]) -> bool:
    balance = 0
    for op in operations:
        balance += op
        if balance < 0:
            return True
    return False","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
",True,5220.898,2026-02-06T21:11:17.814752
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,4,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
    # Calculate the mean of the numbers
    mean_value = sum(numbers) / len(numbers)
    
    # Compute the absolute differences from the mean
    abs_diffs = [abs(x - mean_value) for x in numbers]
    
    # Calculate the average of these absolute differences
    mad = sum(abs_diffs) / len(numbers)
    
    return mad","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
",True,12644.687,2026-02-06T21:11:30.459464
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,5,"from typing import List


def intersperse(numbers: List[int], delimiter: int) -> List[int]:
    result = []
    for i, num in enumerate(numbers):
        result.append(num)
        if i < len(numbers) - 1:
            result.append(delimiter)
    return result","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
",True,4893.518,2026-02-06T21:11:35.353027
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,6,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    # Split the input string into individual groups
    groups = paren_string.split()
    result = []

    for group in groups:
        max_depth = 0
        current_depth = 0

        for char in group:
            if char == '(':
                current_depth += 1
                max_depth = max(max_depth, current_depth)
            elif char == ')':
                current_depth -= 1

        result.append(max_depth)

    return result","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
",True,7987.426,2026-02-06T21:11:43.340475
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,7,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
    return [s for s in strings if substring in s]","    return [x for x in strings if substring in x]
",True,6390.634999999999,2026-02-06T21:11:49.731149
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,8,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
    total_sum = 0
    total_product = 1

    for number in numbers:
        total_sum += number
        total_product *= number

    return total_sum, total_product","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
",True,9793.557,2026-02-06T21:11:59.524734
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,9,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    max_so_far = numbers[0]
    rolling_max_list = [max_so_far]

    for number in numbers[1:]:
        if number > max_so_far:
            max_so_far = number
        rolling_max_list.append(max_so_far)

    return rolling_max_list","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
",False,6325.467,2026-02-06T21:12:05.850224
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,10,"def make_palindrome(string: str) -> str:
    if not string:
        return ''
    
    for i in range(len(string)):
        # Check if the substring from 0 to (len(string) - i) is a palindrome
        if string[i:] == string[i:][::-1]:
            # The longest palindromic suffix found, now append the reverse of prefix to it
            return string + string[:i][::-1]
    
    # If no proper palindromic suffix was found (which theoretically shouldn't happen), just return the original reversed plus itself.
    return string + string[::-1]","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
",True,11251.296,2026-02-06T21:12:17.101567
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,11,"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    """"""
    result = ''
    for bit_a, bit_b in zip(a, b):
        # Perform XOR operation
        xor_bit = '1' if bit_a != bit_b else '0'
        result += xor_bit
    return result


# Test the function with provided test case
assert string_xor('010', '110') == '100'","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
",True,9803.598,2026-02-06T21:12:26.905200
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,12,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    if not strings:
        return None

    longest_string = """"
    max_length = 0

    for s in strings:
        if len(s) > max_length:
            longest_string = s
            max_length = len(s)

    return longest_string","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
",True,7980.59,2026-02-06T21:12:34.885813
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,13,"def greatest_common_divisor(a: int, b: int) -> int:
    while b != 0:
        a, b = b, a % b
    return a","    while b:
        a, b = b, a % b
    return a
",True,5432.152,2026-02-06T21:12:40.317994
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,14,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """"""
    prefixes = []
    for i in range(len(string)):
        prefixes.append(string[:i+1])
    return prefixes","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
",True,8442.443000000001,2026-02-06T21:12:48.760461
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,15,"```python
def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
    return "" "".join(str(i) for i in range(n + 1))
```","    return ' '.join([str(x) for x in range(n + 1)])
",True,6221.019,2026-02-06T21:12:54.981527
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,16,"```python
def count_distinct_characters(string: str) -> int:
    # Convert the string to lower case to ignore case sensitivity
    lower_case_string = string.lower()
    
    # Use a set to store unique characters
    unique_chars = set(lower_case_string)
    
    # The number of distinct characters is the size of the set
    return len(unique_chars)
```","    return len(set(string.lower()))
",True,7532.56,2026-02-06T21:13:02.514102
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,17,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
    result = []
    i = 0
    while i < len(music_string):
        if music_string[i] == 'o':
            result.append(4)
            i += 1
        elif music_string[i:i+2] == 'o|':
            result.append(2)
            i += 2
        elif music_string[i:i+2] == '.|':
            result.append(1)
            i += 2
    return result","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
",False,19121.8,2026-02-06T21:13:21.635927
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,18,"```python
def how_many_times(string: str, substring: str) -> int:
    count = 0
    sub_len = len(substring)
    
    # Iterate through the string with an index that allows for overlapping checks
    for i in range(len(string) - sub_len + 1):
        if string[i:i+sub_len] == substring:
            count += 1
            
    return count
```","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
",True,6740.59,2026-02-06T21:13:28.376540
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,19,"from typing import List


def sort_numbers(numbers: str) -> str:
    # Step 1: Create a dictionary for word-to-number mapping
    numeral_map = {
        'zero': 0, 'one': 1, 'two': 2, 'three': 3,
        'four': 4, 'five': 5, 'six': 6, 'seven': 7,
        'eight': 8, 'nine': 9
    }

    # Step 2: Split the input string into a list of words
    words = numbers.split()

    # Step 3 & 4: Convert each word to its numeric value and sort them
    sorted_numbers = sorted((numeral_map[word] for word in words))

    # Step 5: Map the sorted numeric values back to their corresponding words
    sorted_words = [str(numeral_map.inverse.get(num, '')) for num in sorted_numbers]

    # Step 6: Join these words into a single space-delimited string and return it
    return ' '.join(sorted_words)","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
",False,14411.296,2026-02-06T21:13:42.787851
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,20,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    # Sort the list to make sure all potential pairs are adjacent
    sorted_numbers = sorted(numbers)
    
    # Initialize variables to store the closest pair and their minimum difference
    min_diff = float('inf')
    closest_pair = (0.0, 0.0)
    
    # Iterate through the sorted list to find the closest pair
    for i in range(len(sorted_numbers) - 1):
        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])
        if diff < min_diff:
            min_diff = diff
            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])
    
    return closest_pair","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
",True,10001.32,2026-02-06T21:13:52.789204
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,21,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    if len(numbers) < 2:
        raise ValueError(""List must contain at least two elements"")

    min_num = min(numbers)
    max_num = max(numbers)

    return [(x - min_num) / (max_num - min_num) for x in numbers]","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
",True,9873.646,2026-02-06T21:14:02.662897
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,22,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
    return [value for value in values if isinstance(value, int)]","    return [x for x in values if isinstance(x, int)]
",True,6990.175,2026-02-06T21:14:09.653097
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,23,"def strlen(string: str) -> int:
    return len(string)","    return len(string)
",True,4190.417,2026-02-06T21:14:13.843565
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,24,"def largest_divisor(n: int) -> int:
    for i in range(n - 1, 0, -1):
        if n % i == 0:
            return i
    return 1","    for i in reversed(range(n)):
        if n % i == 0:
            return i
",True,5245.835999999999,2026-02-06T21:14:19.089430
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,25,"from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
    factors = []
    # Check for number of 2s that divide n
    while n % 2 == 0:
        factors.append(2)
        n //= 2

    # n must be odd at this point so we can skip one element (Note i = i + 2)
    for i in range(3, int(n**0.5) + 1, 2):
        # While i divides n, append i and divide n
        while n % i == 0:
            factors.append(i)
            n //= i

    # This condition is to handle the case when n is a prime number greater than 2
    if n > 2:
        factors.append(n)

    return factors","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
",True,17956.688,2026-02-06T21:14:37.046141
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,26,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    num_count = {}
    for num in numbers:
        if num in num_count:
            num_count[num] += 1
        else:
            num_count[num] = 1

    result = [num for num in numbers if num_count[num] == 1]
    return result","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
",True,7280.119,2026-02-06T21:14:44.326335
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,27,"```python
def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    >>> flip_case('Hello')
    'hELLO'
    """"""
    result = """"
    for char in string:
        if char.isupper():
            result += char.lower()
        elif char.islower():
            result += char.upper()
        else:
            result += char
    return result
```","    return string.swapcase()
",True,9679.233999999999,2026-02-06T21:14:54.005601
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,28,"from typing import List


def concatenate(strings: List[str]) -> str:
    return ''.join(strings)","    return ''.join(strings)
",True,4111.2570000000005,2026-02-06T21:14:58.116888
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,29,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
    return [s for s in strings if s.startswith(prefix)]","    return [x for x in strings if x.startswith(prefix)]
",True,6062.364,2026-02-06T21:15:04.179288
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,30,"```python
def get_positive(l: list):
    """"""Return only positive numbers in the list.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
    return [num for num in l if num > 0]
```","    return [e for e in l if e > 0]
",True,8053.990000000001,2026-02-06T21:15:12.233298
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,31,"```python
import math

def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
    if n <= 1:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True
```","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
",False,9788.792000000001,2026-02-06T21:15:22.022117
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,32,"import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
    n = len(xs)
    if n % 2 != 0:
        raise ValueError(""The number of coefficients must be even."")
    
    # Find the index of the largest non-zero coefficient
    max_index = max(range(n), key=lambda i: abs(xs[i]))
    
    # Initial guess for the root based on the largest non-zero coefficient's index
    x0 = 1.0 / (n - max_index)
    
    def f(x):
        return poly(xs, x)
    
    def df(x):
        return sum(i * coeff * math.pow(x, i - 1) for i, coeff in enumerate(xs))
    
    # Newton-Raphson method
    tol = 1e-6
    max_iter = 1000
    x = x0
    
    for _ in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return round(x, 2)
        
        dfx = df(x)
        if dfx == 0:
            break
        
        x -= fx / dfx
    
    raise ValueError(""Failed to converge to a root."")","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
",False,22710.817,2026-02-06T21:15:44.732963
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,33,"```python
def sort_third(l: list):
    # Extract elements at indices divisible by 3
    third_indices = [l[i] for i in range(len(l)) if i % 3 == 0]
    # Sort these extracted elements
    third_indices.sort()
    
    # Replace the original elements with sorted ones at their respective positions
    sorted_list = l.copy()  # Create a copy to avoid modifying the original list directly
    sorted_index = 0
    for i in range(len(l)):
        if i % 3 == 0:
            sorted_list[i] = third_indices[sorted_index]
            sorted_index += 1
    
    return sorted_list
```","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
",False,9825.215,2026-02-06T21:15:54.558195
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,34,"def unique(l: list):
    """"""Return sorted unique elements in a list
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
    return sorted(set(l))","    return sorted(list(set(l)))
",True,7044.635,2026-02-06T21:16:01.602850
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,35,"def max_element(l: list):
    return max(l)","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
",True,2815.882,2026-02-06T21:16:04.418760
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,36,"def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
",True,5659.038,2026-02-06T21:16:10.077813
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,37,"```python
def sort_even(l: list):
    # Extract elements at even indices (0, 2, 4, ...)
    even_elements = [l[i] for i in range(0, len(l), 2)]
    
    # Sort the extracted even-indexed elements
    sorted_even_elements = sorted(even_elements)
    
    # Merge the sorted even-indexed elements back into their original positions
    l_prime = []
    even_index = 0
    for i in range(len(l)):
        if i % 2 == 0:
            l_prime.append(sorted_even_elements[even_index])
            even_index += 1
        else:
            l_prime.append(l[i])
    
    return l_prime
```","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
",True,9718.648,2026-02-06T21:16:19.796484
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,38,"def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
    # split string into groups of three characters
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # reverse the cycling operation on each group
    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]
    return """".join(groups)","    return encode_cyclic(encode_cyclic(s))
",False,8261.283000000001,2026-02-06T21:16:28.057792
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,39,"```python
def prime_fib(n: int) -> int:
    """"""
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
    
    def is_prime(num: int) -> bool:
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    a, b = 0, 1
    count = 0
    while count < n:
        a, b = b, a + b
        if is_prime(a):
            count += 1
    return a","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
",True,13003.349999999999,2026-02-06T21:16:41.061180
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,40,"```python
def triples_sum_to_zero(l: list) -> bool:
    n = len(l)
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False

# Test cases
print(triples_sum_to_zero([1, 3, 5, 0]))  # Expected: False
print(triples_sum_to_zero([1, 3, -2, 1]))  # Expected: True
print(triples_sum_to_zero([1, 2, 3, 7]))  # Expected: False
print(triples_sum_to_zero([2, 4, -5, 3, 9, 7]))  # Expected: True
print(triples_sum_to_zero([1]))  # Expected: False
```","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
",True,10946.571,2026-02-06T21:16:52.007784
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,41,"def car_race_collision(n: int) -> int:
    """"""
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """"""
    return n * n","    return n**2
",True,9025.447,2026-02-06T21:17:01.033239
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,42,"```python
def incr_list(l: list):
    result = []
    for num in l:
        result.append(num + 1)
    return result
```","    return [(e + 1) for e in l]
",True,4536.753,2026-02-06T21:17:05.570025
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,43,"```python
def pairs_sum_to_zero(l):
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False
```","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
",True,6019.918,2026-02-06T21:17:11.589978
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,44,"```python
def change_base(x: int, base: int) -> str:
    if x == 0:
        return ""0""
    
    digits = []
    while x > 0:
        digit = x % base
        digits.append(str(digit))
        x //= base
    
    # The last remaining number is the most significant digit.
    digits.append(str(x))
    
    # Reverse and join to get the final string representation.
    return ''.join(digits[::-1])
```","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
",False,12009.139,2026-02-06T21:17:23.599145
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,45,"def triangle_area(a, h):
    return 0.5 * a * h","    return a * h / 2.0
",True,3924.118,2026-02-06T21:17:27.523297
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,46,"def fib4(n: int) -> int:
    if n == 0 or n == 1:
        return 0
    elif n == 2:
        return 2
    elif n == 3:
        return 0

    # Initialize the first four values of the sequence
    a, b, c, d = 0, 0, 2, 0

    # Compute fib4(n) iteratively
    for i in range(4, n + 1):
        next_value = a + b + c + d
        a, b, c, d = b, c, d, next_value

    return d","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
",True,9073.216,2026-02-06T21:17:36.596538
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,47,"```python
def median(l: list):
    sorted_l = sorted(l)
    n = len(sorted_l)
    mid = n // 2
    
    if n % 2 == 0:
        return (sorted_l[mid - 1] + sorted_l[mid]) / 2
    else:
        return sorted_l[mid]
```","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
",True,5357.0289999999995,2026-02-06T21:17:41.953596
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,48,"```python
def is_palindrome(text: str) -> bool:
    """"""
    Checks if given string is a palindrome
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
    return text == text[::-1]
```","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
",True,8772.807,2026-02-06T21:17:50.726421
qwen2.5:7b_local_baseline_code,qwen2.5:7b,code,49,"```python
def modp(n: int, p: int) -> int:
    return pow(2, n, p)
```","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
",True,5229.691,2026-02-06T21:17:55.956143
